// index.js (ÏôÑÏ†ÑÌåê)
const sqlite3 = require("sqlite3");
const { open } = require("sqlite");
const cron = require("node-cron");
const express = require("express");
const process = require("process");
const { Client, GatewayIntentBits, Partials, REST, Routes, SlashCommandBuilder } = require("discord.js");

////////////////////////////////////////////////////////////////////////////////
// ÏõπÏÑúÎ≤Ñ
////////////////////////////////////////////////////////////////////////////////
const app = express();
const PORT = process.env.PORT || 3000;
app.get("/", (req, res) => res.send("Î¥á Ïã§Ìñâ Ï§ë"));
app.listen(PORT, () => console.log(`ÏõπÏÑúÎ≤Ñ Ìè¨Ìä∏ ${PORT}ÏóêÏÑú Ïã§Ìñâ Ï§ë`));

////////////////////////////////////////////////////////////////////////////////
// ÌôòÍ≤Ω Î≥ÄÏàò
////////////////////////////////////////////////////////////////////////////////
const TOKEN = process.env.DISCORD_TOKEN;
const CLIENT_ID = process.env.CLIENT_ID || null;
const GUILD_ID = process.env.GUILD_ID || null;
const ADMIN_USER_IDS = (process.env.ADMIN_USER_IDS || "").split(",").filter(Boolean);

////////////////////////////////////////////////////////////////////////////////
// Í∏∞Î≥∏ ÏÑ§Ï†ï
////////////////////////////////////////////////////////////////////////////////
const DEFAULT_STARTING = 1000;
const SLOT_DEFAULT_BET = 100;
const RACE_PAYOUT_MULTIPLIER = 5;

////////////////////////////////////////////////////////////////////////////////
// DB Ï¥àÍ∏∞Ìôî
////////////////////////////////////////////////////////////////////////////////
let db;
async function initDB() {
  db = await open({ filename: "./dovakbot.db", driver: sqlite3.Database });
  await db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY,
      balance INTEGER DEFAULT 0,
      last_claim INTEGER DEFAULT 0
    );
    CREATE TABLE IF NOT EXISTS transactions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id TEXT,
      delta INTEGER,
      reason TEXT,
      ts INTEGER
    );
    CREATE TABLE IF NOT EXISTS lottery_tickets (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id TEXT,
      ticket_number TEXT,
      ts INTEGER
    );
  `);
  console.log("DB Ïó∞Í≤∞ ÏÑ±Í≥µ");
}

////////////////////////////////////////////////////////////////////////////////
// Ïú†Ìã∏Î¶¨Ìã∞
////////////////////////////////////////////////////////////////////////////////
function isAdmin(userId) {
  return ADMIN_USER_IDS.includes(userId);
}

async function getUser(userId) {
  const row = await db.get("SELECT * FROM users WHERE id = ?", userId);
  if (!row) {
    await db.run("INSERT INTO users(id, balance, last_claim) VALUES(?,?,?)", userId, 0, 0);
    const newRow = await db.get("SELECT * FROM users WHERE id = ?", userId);
    return { id: newRow.id, balance: Number(newRow.balance || 0), last_claim: newRow.last_claim || 0 };
  }
  return { id: row.id, balance: Number(row.balance || 0), last_claim: row.last_claim || 0 };
}

async function changeBalance(userId, delta, reason = "adjust") {
  const d = Number(delta) || 0;
  await db.run("INSERT INTO transactions(user_id, delta, reason, ts) VALUES(?,?,?,?)", userId, d, reason, Date.now());
  await db.run("UPDATE users SET balance = balance + ? WHERE id = ?", d, userId);
  return getUser(userId);
}

////////////////////////////////////////////////////////////////////////////////
// Discord Client
////////////////////////////////////////////////////////////////////////////////
const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent],
  partials: [Partials.Channel],
});

////////////////////////////////////////////////////////////////////////////////
// Ïä¨Î°ØÎ®∏Ïã†
////////////////////////////////////////////////////////////////////////////////
function spinSlot() {
  const reels = ["üçí", "üçã", "üçä", "üîî", "‚≠ê", "7Ô∏è‚É£"];
  const r1 = reels[Math.floor(Math.random() * reels.length)];
  const r2 = reels[Math.floor(Math.random() * reels.length)];
  const r3 = reels[Math.floor(Math.random() * reels.length)];
  let multiplier = 0;
  if (r1 === r2 && r2 === r3) {
    if (r1 === "7Ô∏è‚É£") multiplier = 10;
    else if (r1 === "‚≠ê") multiplier = 6;
    else multiplier = 4;
  } else if (r1 === r2 || r2 === r3 || r1 === r3) multiplier = 2;
  return { r1, r2, r3, multiplier };
}

////////////////////////////////////////////////////////////////////////////////
// Î∏îÎûôÏû≠
////////////////////////////////////////////////////////////////////////////////
function createDeck() {
  const faces = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
  const deck = [];
  for (let i=0;i<4;i++) for (const f of faces) deck.push(f);
  for (let i=deck.length-1;i>0;i--) {
    const j = Math.floor(Math.random()*(i+1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
  return deck;
}

function calcBlackjackHandValue(hand) {
  let total=0, aces=0;
  for(const c of hand) {
    if(c==="A"){total+=11; aces++;}
    else if(["J","Q","K"].includes(c)) total+=10;
    else total+=Number(c);
  }
  while(total>21 && aces>0){total-=10; aces--;}
  return total;
}

////////////////////////////////////////////////////////////////////////////////
// Î≥µÍ∂å
////////////////////////////////////////////////////////////////////////////////
async function runLotteryDraw(channel) {
  const tickets = await db.all("SELECT * FROM lottery_tickets");
  if(!tickets || tickets.length===0){ if(channel) await channel.send("Ïò§Îäò Î≥µÍ∂å Ï∞∏Ïó¨ÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§."); return; }
  const winnerTicket = tickets[Math.floor(Math.random()*tickets.length)];
  const winnerId = winnerTicket.user_id;
  const prize = tickets.length*100;
  await changeBalance(winnerId, prize, "lottery_prize");
  await db.run("DELETE FROM lottery_tickets");
  if(channel) await channel.send(`<@${winnerId}> ÎãòÏù¥ Î≥µÍ∂å ÎãπÏ≤®! ÏÉÅÍ∏à: ${prize}Ìè¨Ïù∏Ìä∏ üéâ`);
}

function scheduleLottery(channelId){
  cron.schedule("0 0 21 * * *", async ()=>{
    const channel = channelId ? await client.channels.fetch(channelId).catch(()=>null) : null;
    await runLotteryDraw(channel);
  }, {timezone:"Asia/Seoul"});
}

////////////////////////////////////////////////////////////////////////////////
// Í≤ΩÎßà ÏãúÏä§ÌÖú 
////////////////////////////////////////////////////////////////////////////////
const horses = [
  { name: "Ïç¨Îçî", emoji: "üêé" },
  { name: "Ïä§ÌîºÎìú", emoji: "üêé" },
  { name: "ÎùºÏù¥Ìä∏Îãù", emoji: "üêé" },
  { name: "Î∏îÎ†àÏù¥Îìú", emoji: "üêé" },
  { name: "ÌÜ†ÎÑ§Ïù¥ÎèÑ", emoji: "üêé" },
  { name: "Ïä§ÌÉÄ", emoji: "üêé" },
  { name: "Ïç¨ÏÉ§Ïù∏", emoji: "üêé" },
];
const activeRaces = new Map();

async function startRace(channel, bettors) {
  let positions = new Array(horses.length).fill(0);
  const trackLength = 30;
  const msg = await channel.send("üèÅ Í≤ΩÏ£º ÏãúÏûë! Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî...");

  return new Promise((resolve) => {
    let finished = false;
    const interval = setInterval(async () => {
      for (let i = 0; i < horses.length; i++) {
        positions[i] += Math.floor(Math.random() * 3); // 0..2
        if (positions[i] > trackLength) positions[i] = trackLength;
      }

      const raceMsg = positions
        .map((p, i) => `${horses[i].emoji} ${horses[i].name.padEnd(8, " ")} |${"¬∑".repeat(p)}${" ".repeat(Math.max(0, trackLength - p))}üèÅ`)
        .join("\n");

      try { await msg.edit(`üèá Í≤ΩÏ£º Ï§ë...\n\n${raceMsg}`); } catch (e) { /* Ìé∏Ïßë Ïã§Ìå® Î¨¥Ïãú (Í∂åÌïú/Î©îÏãúÏßÄ ÏÇ≠Ï†ú Îì±) */ }

      const winnerIdx = positions.findIndex(p => p >= trackLength);
      if (winnerIdx !== -1) {
        finished = true;
        clearInterval(interval);

        // Ï†ïÏÇ∞: Î≤†ÌåÖÏùÄ Ïù¥ÎØ∏ Ï∞®Í∞êÎêòÏñ¥ ÏûàÏúºÎØÄÎ°ú 'Ï¥ùÏï°'ÏùÑ ÏßÄÍ∏â (Ïòà: multiplier=5 => ÏßÄÍ∏â = 5*bet, net = -bet + 5*bet = +4*bet)
        for (const [uid, b] of bettors.entries()) {
          if (b.horseIndex === winnerIdx) {
            const payout = Number(b.bet) * Number(RACE_PAYOUT_MULTIPLIER);
            await changeBalance(uid, payout, "race_win");
          }
        }

        await channel.send(`üèÜ Í≤ΩÏ£º Ï¢ÖÎ£å! Ïö∞Ïäπ Îßê: ${horses[winnerIdx].name} ${horses[winnerIdx].emoji} (Î≤àÌò∏ ${winnerIdx + 1})`);
        resolve(winnerIdx);
      }
    }, 1000);

    // ÌÉÄÏûÑÏïÑÏõÉ Î∞©ÏßÄ
    setTimeout(() => {
      if (!finished) {
        clearInterval(interval);
        try { msg.reply("‚è± Í≤ΩÏ£ºÍ∞Ä ÏãúÍ∞ÑÏ¥àÍ≥ºÎ°ú Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§."); } catch (e) {}
        resolve(null);
      }
    }, 40000);
  });
}


////////////////////////////////////////////////////////////////////////////////
// Ïä¨ÎûòÏãú Î™ÖÎ†π Îì±Î°ù
////////////////////////////////////////////////////////////////////////////////
const commandList=[
  new SlashCommandBuilder().setName("ÎèàÏ§ò").setDescription("Í∏∞Î≥∏Í∏à ÏßÄÍ∏â"),
  new SlashCommandBuilder().setName("ÏûîÍ≥†").setDescription("ÏûîÍ≥† Ï°∞Ìöå"),
  new SlashCommandBuilder().setName("Ïä¨Î°Ø").setDescription("Ïä¨Î°ØÎ®∏Ïã†").addIntegerOption(o=>o.setName("Î∞∞ÌåÖ").setDescription("Î∞∞ÌåÖ Í∏àÏï°")),
  new SlashCommandBuilder().setName("Î≥µÍ∂åÍµ¨Îß§").setDescription("Î≥µÍ∂å Íµ¨Îß§").addIntegerOption(o=>o.setName("ÏàòÎüâ").setDescription("Ïû• Ïàò")),
  new SlashCommandBuilder().setName("Î≥µÍ∂åÏÉÅÌÉú").setDescription("Î≥µÍ∂å ÏÉÅÌÉú"),
  new SlashCommandBuilder().setName("Í≥®Îùº").setDescription("ÏòµÏÖò Ï§ëÏóêÏÑú Î¨¥ÏûëÏúÑ ÏÑ†ÌÉù").addStringOption(o=>o.setName("option").setDescription("Ïòà: ÏÇ¨Í≥º,Î∞îÎÇòÎÇò,Í∑§").setRequired(true)).addIntegerOption(o=>o.setName("count").setDescription("Ìïú Î≤àÏóê ÎΩëÏùÑ Í∞úÏàò")),
  new SlashCommandBuilder().setName("Í¥ÄÎ¶¨ÏûêÏßÄÍ∏â").setDescription("Í¥ÄÎ¶¨Ïûê Ìè¨Ïù∏Ìä∏ Ï°∞Ï†ï").addUserOption(o=>o.setName("ÎåÄÏÉÅ").setDescription("ÎåÄÏÉÅ Ïú†Ï†Ä").setRequired(true)).addIntegerOption(o=>o.setName("Í∏àÏï°").setDescription("ÏñëÏàò=ÏßÄÍ∏â, ÏùåÏàò=ÌöåÏàò").setRequired(true)),
  new SlashCommandBuilder().setName("Í≤ΩÎßà").setDescription("Í≤ΩÎßà Í≤åÏûÑ").addIntegerOption(o=>o.setName("Î≤àÌò∏").setDescription("1~7Î≤à ÏÑ†ÌÉù").setRequired(true)).addIntegerOption(o=>o.setName("Î∞∞ÌåÖ").setDescription("Î∞∞ÌåÖ Í∏àÏï°")),
  new SlashCommandBuilder().setName("Î∏îÎûôÏû≠").setDescription("Î∏îÎûôÏû≠ Í≤åÏûÑ").addIntegerOption(o=>o.setName("Î∞∞ÌåÖ").setDescription("Î∞∞ÌåÖ Í∏àÏï°")),
  new SlashCommandBuilder().setName("Î∞îÏπ¥Îùº").setDescription("Î∞îÏπ¥Îùº Í≤åÏûÑ").addStringOption(o=>o.setName("Î∞∞ÌåÖÎ∞©Ìñ•").setDescription("ÌîåÎ†àÏù¥Ïñ¥/Î±ÖÏª§/Î¨¥ÏäπÎ∂Ä")).addIntegerOption(o=>o.setName("Î∞∞ÌåÖ").setDescription("Î∞∞ÌåÖ Í∏àÏï°"))
].map(cmd=>cmd.toJSON());

async function registerCommands(){
  if(!CLIENT_ID||!TOKEN) return;
  const rest=new REST({version:"10"}).setToken(TOKEN);
  try{
    if(GUILD_ID) await rest.put(Routes.applicationGuildCommands(CLIENT_ID,GUILD_ID),{body:commandList});
    else await rest.put(Routes.applicationCommands(CLIENT_ID),{body:commandList});
    console.log("Ïä¨ÎûòÏãú Î™ÖÎ†π Îì±Î°ù ÏôÑÎ£å");
  }catch(e){console.error("Î™ÖÎ†π Îì±Î°ù Ïã§Ìå®",e);}
}

////////////////////////////////////////////////////////////////////////////////
// interactionCreate
////////////////////////////////////////////////////////////////////////////////
client.on("interactionCreate", async interaction=>{
  if(!interaction.isChatInputCommand()) return;
  const cmd=interaction.commandName;
  const uid=interaction.user.id;
  try{
    // ÎèàÏ§ò
    if(cmd==="ÎèàÏ§ò"){
      const user=await getUser(uid);
      const now=Date.now();
      const dayMs=24*60*60*1000;
      if(now-(user.last_claim||0)<dayMs){ await interaction.reply({content:"Ïù¥ÎØ∏ 24ÏãúÍ∞Ñ ÎÇ¥ ÏßÄÍ∏âÎê®",ephemeral:true}); return; }
      await db.run("UPDATE users SET balance = balance + ?, last_claim = ? WHERE id = ?",DEFAULT_STARTING,now,uid);
      await db.run("INSERT INTO transactions(user_id, delta, reason, ts) VALUES(?,?,?,?)",uid,DEFAULT_STARTING,"daily_claim",now);
      await interaction.reply({content:`Í∏∞Î≥∏Í∏à ${DEFAULT_STARTING} ÏßÄÍ∏â ÏôÑÎ£å`,ephemeral:true});
      return;
    }

    // ÏûîÍ≥†
    if(cmd==="ÏûîÍ≥†"){
      const user=await getUser(uid);
      await interaction.reply({content:`ÏûîÍ≥†: ${user.balance}Ìè¨Ïù∏Ìä∏`,ephemeral:true});
      return;
    }

    // Ïä¨Î°Ø
    if(cmd==="Ïä¨Î°Ø"){
      const bet=Number(interaction.options.getInteger("Î∞∞ÌåÖ")??SLOT_DEFAULT_BET);
      if(bet<=0){await interaction.reply({content:"Î∞∞ÌåÖÏùÄ ÏñëÏàòÏó¨Ïïº Ìï©ÎãàÎã§",ephemeral:true});return;}
      const user=await getUser(uid);
      if(user.balance<bet){await interaction.reply({content:"ÏûîÍ≥† Î∂ÄÏ°±",ephemeral:true});return;}
      await changeBalance(uid,-bet,"slot_bet");
      const spin=spinSlot();
      if(spin.multiplier>0) await changeBalance(uid,bet*spin.multiplier,"slot_win");
      const newBal=(await getUser(uid)).balance;
      await interaction.reply({content:`Ïä¨Î°Ø Í≤∞Í≥º: ${spin.r1} ${spin.r2} ${spin.r3}\n${spin.multiplier>0?`ÏäπÎ¶¨! Î∞∞Ïàò: ${spin.multiplier}`:`ÍΩù!`}\nÌòÑÏû¨ ÏûîÍ≥†: ${newBal}`});
      return;
    }

    // Î≥µÍ∂åÍµ¨Îß§
    if(cmd==="Î≥µÍ∂åÍµ¨Îß§"){
      const qty=Number(interaction.options.getInteger("ÏàòÎüâ")??1);
      if(qty<=0){await interaction.reply({content:"1Ïû• Ïù¥ÏÉÅ Íµ¨Îß§ÌïòÏÑ∏Ïöî",ephemeral:true});return;}
      const price=qty*1000;
      const user=await getUser(uid);
      if(user.balance<price){await interaction.reply({content:"ÏûîÍ≥† Î∂ÄÏ°±",ephemeral:true});return;}
      for(let i=0;i<qty;i++){
        const ticket=Math.random().toString(36).slice(2,10).toUpperCase();
        await db.run("INSERT INTO lottery_tickets(user_id, ticket_number, ts) VALUES(?,?,?)",uid,ticket,Date.now());
      }
      await changeBalance(uid,-price,"lottery_buy");
      await interaction.reply({content:`${qty}Ïû• Íµ¨Îß§ ÏôÑÎ£å (Ï¥ù ${price}Ìè¨Ïù∏Ìä∏ Ï∞®Í∞ê)`});
      return;
    }

    // Î≥µÍ∂åÏÉÅÌÉú
    if(cmd==="Î≥µÍ∂åÏÉÅÌÉú"){
      const cntRow=await db.get("SELECT COUNT(*) as c FROM lottery_tickets");
      const cnt=cntRow?Number(cntRow.c||0):0;
      await interaction.reply({content:`ÌòÑÏû¨ Î≥µÍ∂å ÌåêÎß§Îüâ: ${cnt}Ïû•`,ephemeral:true});
      return;
    }

    // Í¥ÄÎ¶¨ÏûêÏßÄÍ∏â
    if(cmd==="Í¥ÄÎ¶¨ÏûêÏßÄÍ∏â"){
      if(!isAdmin(uid)){await interaction.reply({content:"Í¥ÄÎ¶¨Ïûê Ï†ÑÏö©",ephemeral:true});return;}
      const target=interaction.options.getUser("ÎåÄÏÉÅ");
      const amount=Number(interaction.options.getInteger("Í∏àÏï°")||0);
      if(!target){await interaction.reply({content:"ÎåÄÏÉÅ ÏßÄÏ†ï ÌïÑÏöî",ephemeral:true});return;}
      await changeBalance(target.id,amount,"admin_adjust");
      await interaction.reply({content:`<@${target.id}>ÏóêÍ≤å ${amount}Ìè¨Ïù∏Ìä∏ Ï†ÅÏö© ÏôÑÎ£å`});
      return;
    }

    // Í≥®Îùº
    if(cmd==="Í≥®Îùº"){
      await interaction.deferReply();
      const raw=(interaction.options.getString("option")||"").trim();
      let count=Number(interaction.options.getInteger("count")||1);
      if(!raw){await interaction.editReply("ÏòµÏÖòÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.");return;}
      const parts=raw.split(/\s*,\s*|\s*\/\s*|\s+or\s+|\r?\n|[,;]\s*|\s+/i).map(s=>s.trim()).filter(Boolean);
      if(parts.length===0){await interaction.editReply("Ïú†Ìö®Ìïú ÏòµÏÖòÏù¥ ÏóÜÏäµÎãàÎã§.");return;}
      if(!Number.isInteger(count)||count<1) count=1;
      if(count>parts.length) count=parts.length;
      const shuffled=parts.sort(()=>Math.random()-0.5);
      const picks=shuffled.slice(0,count);
      const content=count===1?`‚úÖ ÏÑ†ÌÉù: **${picks[0]}**\n(Ï¥ù ${parts.length}Í∞ú ÏòµÏÖò Ï§ë)`: `‚úÖ ${count}Í∞ú ÏÑ†ÌÉù: ${picks.map(p=>`**${p}**`).join(", ")}\n(Ï¥ù ${parts.length}Í∞ú ÏòµÏÖò Ï§ë)`;
      await interaction.editReply(content);
      return;
    }

    // Í≤ΩÎßà
    if(cmd==="Í≤ΩÎßà"){
      await interaction.deferReply();
      const number=interaction.options.getInteger("Î≤àÌò∏")-1;
      const bet=interaction.options.getInteger("Î∞∞ÌåÖ")||100;
      if(number<0||number>=horses.length){await interaction.editReply("Î≤àÌò∏Îäî 1~7 ÏÇ¨Ïù¥Ïó¨Ïïº Ìï©ÎãàÎã§.");return;}
      const user=await getUser(uid);
      if(user.balance<bet){await interaction.editReply("ÏûîÍ≥† Î∂ÄÏ°±");return;}
      await changeBalance(uid,-bet,"race_bet");
      const bettors=new Map();
      bettors.set(uid,{horseIndex:number,bet});
      const winnerIdx=await startRace(interaction.channel,bettors);
      const newBal=(await getUser(uid)).balance;
      await interaction.editReply(`üèÅ Í≤ΩÎßà Ï¢ÖÎ£å! ÌòÑÏû¨ ÏûîÍ≥†: ${newBal}`);
      return;
    }

    // Î∏îÎûôÏû≠
    if(cmd==="Î∏îÎûôÏû≠"){
      await interaction.deferReply();
      const bet=interaction.options.getInteger("Î∞∞ÌåÖ")||100;
      const user=await getUser(uid);
      if(bet<=0||user.balance<bet){await interaction.editReply("Î∞∞ÌåÖ Í∏àÏï° Ïò§Î•ò ÎòêÎäî ÏûîÍ≥† Î∂ÄÏ°±");return;}
      await changeBalance(uid,-bet,"blackjack_bet");
      const deck=createDeck(), draw=()=>deck.pop();
      const playerCards=[draw(),draw()], dealerCards=[draw(),draw()];
      let playerTotal=calcBlackjackHandValue(playerCards), dealerTotal=calcBlackjackHandValue(dealerCards);
      while(playerTotal<17){playerCards.push(draw());playerTotal=calcBlackjackHandValue(playerCards);}
      while(dealerTotal<17){dealerCards.push(draw());dealerTotal=calcBlackjackHandValue(dealerCards);}
      let text=`üÉè Î∏îÎûôÏû≠ Í≤∞Í≥º üÉè\nÌîåÎ†àÏù¥Ïñ¥: ${playerCards.join(",")} (${playerTotal})\nÎîúÎü¨: ${dealerCards.join(",")} (${dealerTotal})\n`;
      if(playerTotal>21) text+="‚ùå Î≤ÑÏä§Ìä∏! Ìå®Î∞∞\n";
      else if(dealerTotal>21||playerTotal>dealerTotal){ await changeBalance(uid,bet*2,"blackjack_win"); text+="‚úÖ ÏäπÎ¶¨!\n"; }
      else if(playerTotal===dealerTotal){ await changeBalance(uid,bet,"blackjack_draw"); text+="ü§ù Î¨¥ÏäπÎ∂Ä\n"; }
      else text+="‚ùå ÎîúÎü¨ ÏäπÎ¶¨\n";
      text+=`ÏûîÍ≥†: ${(await getUser(uid)).balance}`;
      await interaction.editReply(text);
      return;
    }

    // Î∞îÏπ¥Îùº
    if(cmd==="Î∞îÏπ¥Îùº"){
      await interaction.deferReply();
      const side=interaction.options.getString("Î∞∞ÌåÖÎ∞©Ìñ•")||"ÌîåÎ†àÏù¥Ïñ¥";
      const bet=interaction.options.getInteger("Î∞∞ÌåÖ")||100;
      if(!["ÌîåÎ†àÏù¥Ïñ¥","Î±ÖÏª§","Î¨¥ÏäπÎ∂Ä"].includes(side)){await interaction.editReply("Î∞∞ÌåÖ Î∞©Ìñ• Ïò§Î•ò");return;}
      const user=await getUser(uid);
      if(user.balance<bet){await interaction.editReply("ÏûîÍ≥† Î∂ÄÏ°±");return;}
      await changeBalance(uid,-bet,"baccarat_bet");
      const deck=createDeck(), draw=()=>deck.pop();
      const playerCards=[draw(),draw()], bankerCards=[draw(),draw()];
      const baccaratValue=c=>c==="A"?1:["J","Q","K","10"].includes(c)?0:Number(c);
      const calcTotal=cards=>cards.reduce((a,c)=>a+baccaratValue(c),0)%10;
      const playerTotal=calcTotal(playerCards), bankerTotal=calcTotal(bankerCards);
      let winner=playerTotal>bankerTotal?"ÌîåÎ†àÏù¥Ïñ¥":bankerTotal>playerTotal?"Î±ÖÏª§":"Î¨¥ÏäπÎ∂Ä";
      let payout=0,text=`üé¥ Î∞îÏπ¥Îùº Í≤∞Í≥º üé¥\nÌîåÎ†àÏù¥Ïñ¥: ${playerCards.join(",")} (${playerTotal})\nÎ±ÖÏª§: ${bankerCards.join(",")} (${bankerTotal})\n`;
      if(side===winner){
        if(winner==="ÌîåÎ†àÏù¥Ïñ¥") payout=bet*2;
        else if(winner==="Î±ÖÏª§") payout=Math.floor(bet*1.95);
        else payout=bet*9;
        await changeBalance(uid,payout,"baccarat_win");
        text+=`‚úÖ ÏäπÎ¶¨! ÏÉÅÍ∏à ${payout} ÏßÄÍ∏â\n`;
      } else text+=`‚ùå Ìå®Î∞∞. Î∞∞ÌåÖÏï° ${bet} Ï∞®Í∞ê\n`;
      text+=`ÏûîÍ≥†: ${(await getUser(uid)).balance}`;
      await interaction.editReply(text);
      return;
    }

  }catch(e){ console.error(e); try{ if(interaction.deferred||interaction.replied) await interaction.editReply("‚ö†Ô∏è Ïò§Î•ò Î∞úÏÉù"); else await interaction.reply({content:"‚ö†Ô∏è Ïò§Î•ò Î∞úÏÉù",ephemeral:true}); }catch(_){} }
});

////////////////////////////////////////////////////////////////////////////////
// ready
////////////////////////////////////////////////////////////////////////////////
client.once("ready", async()=>{
  console.log(`Logged in as ${client.user.tag}`);
  await initDB();
  await registerCommands();
  if(GUILD_ID){
    const guild=await client.guilds.fetch(GUILD_ID).catch(()=>null);
    if(guild&&guild.systemChannelId) scheduleLottery(guild.systemChannelId);
    else scheduleLottery(null);
  } else scheduleLottery(null);
  console.log("Î¥á Ï§ÄÎπÑ ÏôÑÎ£å");
});

////////////////////////////////////////////////////////////////////////////////
// Î°úÍ∑∏Ïù∏
////////////////////////////////////////////////////////////////////////////////
client.login(TOKEN);
